% !TEX root=./tech-specification.tex

\section{Collateral for Storage}
\label{sec:collateral}

\emph{Collateral for storage} (CFS for short) mechanism is introduced in \name as a pricing method for the usage of storage,
which is more fair and reasonable 
than the one-off storage fee in Ethereum. 
% 
In principle, this mechanism requires a fund being locked as collateral for any occupation of storage space.
The collateral is locked until the corresponding storage is freed or overwritten by someone else,
and the corresponding interest generated by the locked collateral is assigned directly to miners for the maintenance of storage.
Thus, the cost of storage in \name also depends on the duration of space occupation. 

In \name, every entry of storage is \sunitsize, which is exactly the size of a single key/value pair in the world-state.
The required collateral for storage is proportional to the smallest multiple of \sunitsize that are capable to cover all stored items.
For every storage entry, the account that last writes to the entry is 
called \emph{the owner of that storage entry}.
If a storage entry is written in the execution of a contract $\contract$ with sponsorship for collateral, 
then $\contract$ is regarded as the account writing to that entry and hence becomes the owner accordingly (see Section~\ref{sec:sponsor} for more details).
In the whole lifetime of a storage entry in the world-state, 
the owner of that entry must lock a fixed amount of \cfx as collateral for the occupation of storage space. 
In particular, for each storage entry of size \sunitsize the owner should lock \sunitprice. 
This price is essentially $1$ \cfx for \storagepertoken space,
i.e. every byte of storage requires $10^{18}/\storagebytepertoken$ \unit.

At the time that an account $\account$ becomes the owner of a storage entry (at either creation or modification), $\account$ should lock \sunitprice for that entry at the end of transaction execution.
If $\account$ is a normal address, the locked \sunitprice is deducted from its balance. If $\account$ is a contract address, the locked \sunitprice is deducted from its \textbf{sponsor balance for collateral}.
If $\account$ has enough balance then the required collateral is locked automatically,
otherwise if $\account$ does not have enough balance, the whole transaction execution will fail.

When a storage entry is deleted from the world-state, the corresponding \sunitprice collateral is unlocked and returned to the balance of that entry's owner.
In case the ownership of a storage entry is changed, 
the old owner's \sunitprice collateral is unlocked,
while the new owner must lock \sunitprice as collateral at the same time.

For convenience, we introduce the function $\cfs$ which takes an account address $a$ and a world-state $\st$ as input and returns the total amount of \unit's of locked collateral for storage of account $a$ in world-state $\st$.
In case the world-state $\st$ is clear from context, we write $\cfs(a)$ instead of $\cfs(a;\st)$ for succinctness.

\begin{align}
	\cfs(a) \eqdef \cfs(a;\st) \eqdef \st[a]_o
\end{align}

The world state also maintains the total number of locked tokens for collateral, which is stored in storage entry of staking internal contract. We introduce function ${\sf ACFS}$ to read this value from world state $\st$

\begin{align}
	\mathsf{ACFS}(\st) &\eqdef \st[a_{\sf stake}]_{\bf s}[k_4]_v\\
	\mbox{where:} & \\
	a_{\sf stake} &\eqdef \stakingcontract \\ 
	k_4 &\eqdef {\sf [total\char`_storage\char`_tokens]_{\sf ch}} 
\end{align}

\subsection{Storage writing}\label{sec:storage_maintain}

In order to refund the storage collateral to payer when the storage entry is released, Conflux must track the owner for each storage entry. Here we formally describe the storage writing function $\Phi(\st,a,k,v,o)$, which sets storage entry $k$ of account $a$ to value $v$ and address $o$ is the storage owner. It returns updated world-state $\st'$ and a substate $A$.

\begin{align}
	\st'   &\eqdef \st \qquad \mbox{  except:}\\ 
	\st'[a]_{\bf s}[k] &\eqdef\left\{
		\begin{array}{ll}
			(v,o) & v\neq 0\\
			\varnothing & v= 0\\
		\end{array}
	\right.\\
	A^1 &\eqdef A^0  \qquad \mbox{  except:}\\ 
	A^1[s_o]_{\bf c} &\eqdef - 64 \times \collateralperbyte \quad \mbox{ if } v\neq \st[a]_{\bf s}[k]_v \;\wedge\; s_o\neq s'_o \;\wedge\; s_o\neq\varnothing \\ 
	A^2 &\eqdef A^0  \qquad \mbox{  except:}\\ 
	A^2[s'_o]_{\bf c} &\eqdef 64 \times \collateralperbyte \quad \mbox{ if }v\neq \st[a]_{\bf s}[k]_v \;\wedge\; s_o\neq s'_o \;\wedge\; s'_o\neq\varnothing \\ 
	A &\eqdef A^1\Cup A^2 \\
	\text{where:} & \\
	s &\eqdef \st[a]_{\bf s}[k] \\
	s' &\eqdef \st'[a]_{\bf s}[k] 
\end{align}

There are five special storage entries in staking vote contract $\stakingcontract$, which record the statistic information about Conflux blockchain. Their owners are always the staking vote contract and they are exempted from storage collateral. Their keys are list as follows 
\begin{align}
	& \sf [accumulate\char`_interest\char`_rate]_{\sf ch} \\ 
	& \sf [interest\char`_rate]_{\sf ch} \\
    & \sf [total\char`_staking\char`_tokens]_{\sf ch} \\
    & \sf [total\char`_storage\char`_tokens]_{\sf ch} \\
    & \sf [total\char`_issued\char`_tokens]_{\sf ch} 
\end{align}

These five storage entries can only be accessed by the internal contract. In this document, we don't use function $\Phi$ when dealing with these entries and thus function $\Phi$ does not need to consider this special case. 
