% !TEX root = ./tech-specification.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Message Call}\label{sec:execution}
The following intrinsic parameters are used when executing a message call:
\begin{itemize}[nosep]
	\item world-state ${\st}$;
	
	\item sender $s$;

	\item original sender $o$;

	\item recipient $r$;
	
	\item other recipients in call stack ${\bf t}$
	
	\item storage owner $i$

	\item the account $c$ whose code is to be executed, usually the same as recipient; 

	\item available gas $g$;

	\item gas price $p$;

	\item value $v$;

	\item input data $\vec{d}$ of the call, as an arbitrary length byte array;

	\item the present depth of message-call/contraction-creation stack $e$;

	\item and finally the permission to change the state $w$.
\end{itemize}

During the execution of message calls, 
the state and transaction substate may change,
and finally an output data array $\vec{o}$ will be generated.
In case of executing transactions (generated by external controllers) the output data $\vec{o}$ is ignored, however message calls (generated by internal execution process) can result further consequences due to the execution of VM-codes, especially when the message call is generated inside the execution of another message call (or transaction).
\begin{align}
  	\left(\st', g', A, z, \vec{o} \right) \eqdef \execution\left(\st,s,o,r,\vec{t},i,c,g, p,v,\tilde{v},\vec{d},e,w \right)
\end{align}  
Note that we differentiate between the value to be transferred, $v$, from the value apparent in the execution context, $\tilde{v}$, for the $\op{DELEGATECALL}$ instruction.

We let $\st^*$ denote the first transitional world-state, which is the same as the original state except for the value transferred from sender $s$ to recipient $r$ (if $s\ne r$):
\begin{align}
	\st^*[r]_b\eqdef \st[r]_b+v \qquad \land  \qquad\st^*[s]_b\eqdef \st[s]_b-v
	\label{state:first transitional}
\end{align}

In particular, if $\st[r]$ was undefined in $\st$, \name will treat it as an empty account with address $r$ which has no code or state and zero balance and nonce.
If furthermore the transferred value $v$ is positive, the account will be created and stored in $\st^*[r]$. 
Thus the previous equation should be taken to mean:
\begin{align}
	\st^* &\eqdef \st \qquad \mbox{except:}\\
	\st^*\left[ s \right] &\eqdef \begin{cases}
		\varnothing & \mbox{if $\st[s]=\varnothing$ $\land$ $v=0$}\\
		\st[s]\quad\mbox{except:}\st^*[s]_b=\st[s]_b-v & \mbox{otherwise}
	\end{cases}\\
% \end{align}
% \begin{align}
	% \mbox{and}\qquad \st'_1 &\eqdef \st \qquad \mbox{except:}\\
	\st^*[r] &\eqdef \begin{cases}
		\account^0 \quad\text{except:}\; \st^*[r]_b=v  & \mbox{if $\st[r]=\varnothing \;\land\; v\ne 0$}\\
		\varnothing & \mbox{if $\st[r]=\varnothing \;\land\; v = 0$}\\
		\st[r]\quad\mbox{except:}\st^*[r]_b=\st[r]_b+v\; & \mbox{otherwise}
	\end{cases}
\end{align}

The recipient's associated code $\vec{b}$, whose Keccak hash is $\st[c]_c$, is executed according to the execution model.
Note that the code $\vec{b}$ is stored in code component $\st[c]_{code}$ of account $c$. % must be stored at some previous point, i.e. at the last update of the code hash $\st[r]_c$ of the recipient's account. 
% Thus $\vec{b}$ can be efficiently determined from $\st[r]_{code}$,
% and it is unique following the collision resistance of $\kec$.

Similar as with contract creation, if the execution halts due to an exception, then the state is reverted to the point immediately prior to balance transfer (i.e. $\st$) of the message call but no gas is refunded.
The new state $\st'$ after executing this message call is as follows:
\begin{align}
	\st' &\eqdef 
	\begin{cases}
		\st 	 	& \mbox{if $\st^{**}=\varnothing$}\\
		\st^{**} 	& \mbox{otherwise}
	\end{cases}\\
	g' & \eqdef 
	\begin{cases}
		0 & \mbox{if $\st^{**} =\varnothing$ $\land$ $\vec{o}=\varnothing$}\\
		g^{**} & \mbox{otherwise}	
	\end{cases}\\
	z &\eqdef 
	\begin{cases}
		1	 	& \mbox{if $\st^{**}=\varnothing$}\\
		0	 	& \mbox{otherwise}
	\end{cases}
\end{align}
where the resultant state $\st^{**}$ and available gas remaining $g^{**}$, together with the accrued substate $A$ and the output data $\vec{o}$, 
are determined by the code execution function $\execute$ evaluated on state $\st^*$.
\begin{align}
	\left(\st^{**}, g^{**},  A, \vec{o} \right) \eqdef \execute \left(\st^*, g, I  \right)
\end{align}
where $I$ contains the parameters of the execution environment as follows:
\begin{align}
	I_a &\eqdef r\\
	I_o &\eqdef o\\
	I_i &\eqdef i\\
	I_p &\eqdef p\\
	I_\vec{d} &\eqdef \vec{d}\\
	I_\vec{t} &\eqdef \vec{t}\\
	I_s &\eqdef s\\
	I_v &\eqdef \tilde{v}\\
	I_\vec{b} &\eqdef \vec{b}\\
	I_{\head} & \eqdef \head \\
	I_{\mathbf{L}} & \eqdef \mathbf{L}\\ 
	I_e &\eqdef e\\
	I_w &\eqdef w	% I_\vec{b} \;\; &\text{such that }  \kec\left(I_\vec{b}\right)  = \st[r]_c
\end{align}




For the frequently used functionalities such as the elliptic curve public key recovery, the SHA2-$256$ hash scheme, and so on, we set up eight ``precompiled computation contracts'' with reserved code's address $c\in\set{1,2,\dots,8}$ (with type indicator $\typereserved$). The precompiled computation contracts have no side-effect during execution. They will not generate logs, modify accounts' storage or trigger another message call. 
%
In the present implementation of \name these exceptional contracts are specified as in the latest version of Ethereum \cite{ETH_yellow}.

\name also introduces internal contracts for specific usage. A high-level description for the internal contracts is given in Section~\ref{sec:internal}. When the recipient's address $r$ is one of the internal contracts, Conflux processes $\execute_{\sf internal}(\st^*,g,I)$ and returns $\left(\st^{**}, g^{**},  A, \vec{o} \right)$. A formal definition is given in section~\ref{sec:internal_contract}. 

